<h1 align="center">动态代理模式</h1>

>动态代理的意义在于生成一个占位（又称代理对象），来代理真实对象，从而控制真是对象的访问。

## 什么是代理模式

![代理模式](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1788963021,4195928053&fm=26&gp=0.jpg)

### 代理模式中的角色

1. 抽象对象角色

   声明了目标类及代理类对象的共同接口，这样在任何可以使用目标对象的地方都可以使用代理对象。

2. 目标对象角色
   
   定义了代理对象所代表的目标对象。
   
3. 代理对象角色
   
   代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象和目标对象具有统一的接口，以便可以再任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或者之后，执行某些操作，而非单纯的将调用传递给目标对象。
   
因此，代理的作用就是，在真实对象访问之前或者之后加入对应的逻辑，或者根据其他规则控制是否使用真是对象。
我们需要在调用者调用对象之前产生一个代理对象，而这个代理对象需要和真实对象建立代理关系，所以代理必须分为两个步骤：
* 代理对象和真实对象建立代理关系
* 实现代理对象的代理逻辑方法

## Java中的代理

在Java中有多种动态代理技术，比如JDK、CGLIB、Javassist、ASM，其中最常用的是JDK动态代理和CGLIB动态代理。
目前，Spring常用JDK和CGLIB，而MyBatis还使用Javassist。

## JDK动态代理

JDK动态代理是`java.lang.reflect.*`包提供的方式，它必须借助一个接口才能产生代理对象，所以先定义接口，代码清单：

[HelloWorld](../src/main/java/com/zft/proxy/HelloWorld.java)
  
然后提供实现类HelloWorldImpl来实现接口，代码清单：

[HelloWorldImpl](../src/main/java/com/zft/proxy/HelloWorldImpl.java)

现在可以动态代理了，按照之间的分析，先建立代理对象和真实对象的关系，然后实现代理逻辑，分为两步。

在JDK动态代理中，要实现代理逻辑类必须实现`java.lang.reflect.InvocationHandler`接口，它里面定义了一个`invoke`方法，并提供接口数组用于下挂代理对象，代码清单：

[JdkProxyExample](../src/main/java/com/zft/proxy/JdkProxyExample.java)

**第一步，建立代理对象和真实对象之间的关系。** 这里使用bind方法去完成的，方法里面首先用类的属性target保存了真实对象，然后通过如下代码建立并生成代理对象：

`Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),this);`

其中，newProxyInstance方法包含3个参数。

* 第一个是类加载器，我们采用了target本身的类加载器。
* 第二个是把生成的动态代理对象挂在哪些接口下，我们放在target实现的接口下。
* 第三个是定义实现方法逻辑的代理类，this表示当前对象，它必须实现InvocationHandler接口的invoke方法，它就是代理逻辑方法的现实方法

**第二步，实现代理逻辑方法。** invoke方法可以实现代理逻辑，invoke方法的3个参数含义：

* proxy，代理对象，就是bind方法生成的对象
* method，当前调度的方法
* args，调度方法的参数

当我们使用了代理对象调度方法后，它就会进入到invoke方法里面。

`Object obj = method.invoke(target,args)`

这行代码相当于调度真实对象的方法，只是通过反射实现的。

测试JDK动态代理，代码清单：

[TestJdkProxy](../src/main/java/com/zft/proxy/TestJdkProxy.java)

首先通过bind方法绑定了代理关系，然后再代理对象调度sayHelloWorld方法时进入了代理的逻辑，测试结果如下：

```text
进入代理逻辑方法
在调度真实对象之前的服务
Hello World
在调用真实对象之后的服务
```

此时，在调度打印Hello World之前和之后都可以加入相关的逻辑，甚至可以不调度Hello World的打印。

## CGLIB动态代理

JDK动态代理必须提供接口才能使用，在一些不能提供接口的环境中，只能采用其他第三方技术，比如CGLIB动态代理。它的优势在于不需要提供接口，只要一个非抽象类就可以实现动态代理。
选取[ReflectServiceIMpl类](../src/main/java/com/zft/reflect/ReflectServiceImpl.java)作为例子，它不存在实现任何接口，所以没法使用JDK动态代理，这里采用CGLIB动态代理技术，代码清单：

[CglibProxyExample](../src/main/java/com/zft/proxy/CglibProxyExample.java)

测试CGLIB动态代理，代码清单：

[TestCGLIBProxy](../src/main/java/com/zft/proxy/TestCGLIBProxy.java)

注意需要引入cglib依赖:

```xml
    <dependency>
      <groupId>cglib</groupId>
      <artifactId>cglib</artifactId>
      <version>2.2.2</version>
    </dependency>
```